+++
title = "This Week In Veloren 180"
description = ""

date = 2022-07-11
weight = 0
slug = "devblog-180"

[extra]
banner = "https://media.discordapp.net/attachments/523568428905398283/998771000156094554/screenshot_1658179434952.png"

[taxonomies]
tags = ["devblog"]
+++

This week, we have a great writeup from @Sharp about optimizations being made to
the site2 system.

\- AngelOnFira, TWiV Editor

# Contributor Work

Thanks to this week's contributors, @zesterer, @xMAC94x, @DaforLynx, @Isse,
@XVar, @Awkor, @Christof, @Julio, @Slipped, and @Socksonme!

https://gitlab.com/veloren/veloren/-/merge_requests/3183/ 


weather-microfixes has been merged :pogchomp: 
https://discord.com/channels/449602562165833758/953612944518823946

## Socksonme

For the past couple of months, I've been working on a rewrite to the SCT system
that we have. (These are the damage numbers that show up on the screen - both
for the player and the enemies) The old method that was used for creating the
"floaters" had many issues - first: it checked if the health had changed in the
last frame, and second: it only used the last change applied to the health. The
way that the check was made was by storing the hp on the current tick, and then
on the next tick - comparing them to see if they're different. 

The issue that this caused was, that an equal amount of healing and damage done
in the same tick would lead to no damage numbers being shown. The second issue,
which is displaying only the last change, led to some attacks/weapons showing
incorrect damage. For example - the bow's "Shotgun" attack, the slashing damage
from the sword, whenever the enemy doesn't have enough energy left, or the poise
damage, whenever the enemy is stunned. All of these attacks apply multiple
changes to the health, in the same tick, which would obviously cause an issue. 

The new system put in place now uses "outcomes", which are the result of an
event. Whenever an attack is applied, a HealthChange server event is emitted.
This is then handled and then a HealthChange outcome is emitted. Then, for every
HealthChange outcome, we go through some new conditions in order to see how some
health changes should be displayed. Before the HealthChange server event is
emitted, a random number is generated and then stored, since we will want to
group up damage from the same attack (I will explain why later). Another value
that is now stored is the crit boolean, which, as the name suggests, stores
whether a health change was a crit or not. Crits dealt to an enemy are separated
from regular attacks, and they themselves aren't accumulated with other crits.
They are also displayed in a random position left or right from where the
regular attacks show up, ...are a bit larger than the damage numbers for regular
attacks, and have a yellow color. In comparison to the floaters for the enemies,
crits and regular attacks are shown in the same position for the player, and are
accumulated normally, however, they still possess a yellow color. I decided to
also let the player decide the duration for which floaters should be
accumulated. This is done by having two separate sliders going from 0.0 seconds
to 2.0 seconds (one for damage dealt by the player and one for damage damage
dealt to the player). However, this poses another small issue, which is that, if
you have damage from the same attack happening in the same tick, while you have
the damage accumulation duration set to 0 seconds, this would lead to the text
being unreadable. As a method to solve this, as I mentioned before, we check if
this random number (which is the same for damage from the same attack) is the
same, and also if it's from the same tick, and if so - accumulate the damage. 

Some minor changes also include: having a toggleable option for rounding damage
which is greater than or equal to 1.0, having an option for experience number
accumulation (I decided that having a slider for the duration would be
excessive) and some sources of damage/healing - for example fall damage,
campfires, food, the regeneration buff and others, now show up in the SCT. Also,
since we now have a slider for the accumulation duration, I felt that I should
remove both the single and cumulated damage options. (might post some images
later)

## xMAC94x

# The roadway to better server-side physics by @xMAC94x[GMT+2]

There are currently 2 physics modes: client-side physics which is prone to hacks
and has low latency, and server-side physics which is hardly hackable but has
high latency. Here's how we want to get the best out of both.

First lets have a look how current server-side physics works. Assume we have a
Server, ClientA and ClientB. The latency(=ping) of ClientA is 300ms, the latency
of ClientB 200ms. When ClientA jumps it takes 300ms to the server and 200ms to
ClientB. ClientB sees this after 500ms. Even worse: The same goes for ClientA,
it sends the message to the server, waits for the servers answer and starts the
jump animation after 600ms. 600ms till the press of a button and seeing
something happen is unplayable.

Our new server-side physics will work with 2 clever tricks:
 - a client no longer waits for a message to go to the server and back, but will
   start the animation immediately
 - voxygen does not show you what the server sends you, but always "project" a
   latency + a bit in the future.
 
Lets deep dive into the later one. the server counts the time since its start,
the so called tick time. starting with 0s, and increasing every tick by ~33,3ms.
Lets look at what happens at time t=100s. The server makes it calculations and
sends an event to the client: Arrow is flying to your feet and will reach you in
1s! ClientA does not yet know about this arrow, the message hasn't been send
over the internet. It takes 300ms , so at t=100,3s the client receives the
message of the arrow. Now comes the fancy part. ClientA knows the message was
sent at the server at t=100s, so the client will revert it's time back to t=100s
and now simulates 300ms. If we would keep it like that the client would see the
arrow 700ms away. This is good, voxygen already substracted the 300ms for the
latency from server->client. But we dont stop here. We are simulating another
300ms + a bit (lets say 50ms) = 350ms. This way, we are taking into account the
time it will take from the client to the server. The 50ms are a small buffer
that will be explained later. The actually image ClientA will see shows the
arrow only 350ms away from their feet, as we show 100,75s even though the time
is t=100,3s The client now sees exactly what the server will see once their
message arives, so he quickly presses the jump button. ClientA sends a message
to the server: Hey i want to jump at exactly t=100,65s. When the server receives
that message another 300ms are gone, it's not t=100,6s. The server processes the
jump-request and sees: it's still valid, it was send 50ms ahead of time and
starts the jump of ClientA.

All this what we spoke about will repeat endlessly. with each message from the
server additional info is send, e.g.: your message was 50ms early. This will
then be used at the client to tighten the timings and calcualte the ping.

For this algorithm to work flawlessly we need to improve the accuracy of our
tick calculations and physics calculations. We need to predict a-lot of
variables and constantly need to adjust the 50 ms buffer we talked earlier about
so that the image doesn't appear laggy. All this is another story for anther
blog but needs to be done first. Expect it NOT before the next release party.

{{
  img(src="https://cdn.discordapp.com/attachments/523568428905398283/1001893594778583130/unknown.png",
  caption="Ready to fight! See you next week!")
}}

{{ support() }}
