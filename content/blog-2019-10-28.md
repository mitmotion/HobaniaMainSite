+++
title = "This Week In Veloren 39"
description = ""

date = 2019-10-28
weight = 0
slug = "devblog-39"
+++

![banner](https://media.discordapp.net/attachments/634860358623821835/637022419441418240/Capture.PNG?width=1185&height=666)



# Contributor Work

Thanks to this week's contributors, @Imbris, @Slipped, @Timo, @Acrimon, @Pfauenauge, @Songtronix, @soruh, @pestilence, @xMAC94x, @Mckol!

![login-website](https://cdn.discordapp.com/attachments/597826574095613962/638360896124485639/SPOILER_Screenshot_2019-10-28_Veloren_-_Account.png)

> The first design iteration for Veloren's login website

@Songtronix has been working on testing and fixes for Airshipper, which is slated for release soon. @SrMizuki is working on general user interface improvements to try and find a balence between funcitonality, design, and user experience.

# Optimizations by @Imbris

Time for a mini flamegraph story. I hadn't run a flamegraph recently and there had been some improvements to meshing speed among other changes to the engine. I was curious what the current flamegaph would look like, so I gave it a go. The result showed that meshing was still a huge chunk of the flamegraph, especially now that I could crank the view distance up past 25.

Taking another look at it, I discovered there was a portion of the code doing lookups into the volume that didn't use the cached access that I had previously added. It caches the last accessed chunk to prevent a hashmap lookup for every block since most will be in the same chunk. The code of interest looked up adjacent blocks to determine which faces were exposed and thus needed to be meshed.

![flamegraph](https://user-content.gitlab-static.net/bef1ec1fb80fcae5c50776189734dd03ae45bb69/68747470733a2f2f63646e2e646973636f72646170702e636f6d2f6174746163686d656e74732f3436373037333831343230383035333234382f3633363831303439303136343637343537332f756e6b6e6f776e2e706e67)

For a moment I considered using the caching here as well. However, the color smoothing was already accessing all the adjacent blocks which I took advantage of essentially removing redundant block accesses. Now the main bottleneck is the lighting flood calculations which is slated to be moved out of meshing entirely. For more information, check out [!625](https://gitlab.com/veloren/veloren/merge_requests/625)

# 0.5 Intro Meeting

Last weekend, we met up to discus what we were going to achieve in 0.5. Each team lead also gave a run down on what they had worked on during 0.4, and their goals for 0.5. 

![meeting](https://media.discordapp.net/attachments/541307840938377217/638082941599088641/unknown.png?width=153&height=665)

> The meeting attendies list keeps getting longer!

For more information about the meeting, you can take a look at [the meeting minutes](https://docs.google.com/document/d/1bjH88F1ApGjG65evdjZeTnpHK8Vc8NjHB5m7MS9XVHw/edit?usp=sharing).

# Object bug

Oh my this one was interesting. So here's what happens when the client sends /object chair. (for context client communications are run in ecs systems mainly now). the relavant server code looks like this:

```
// 3) Handle inputs from clients
frontend_events.append(&mut self.handle_new_connections()?);

// Handle game events
frontend_events.append(&mut self.handle_events());

let before_tick_4 = Instant::now();
// 4) Tick the client's LocalState.
self.state.tick(dt, sys::add_server_systems);

// Tick the world
self.world.tick(dt);

// 5) Fetch any generated `TerrainChunk`s and insert them into the terrain.
// in sys/terrain.rs

let before_tick_6 = Instant::now();
// 6) Synchronise clients with the new state of the world.
// TODO: Remove sphynx
// Sync 'logical' state using Sphynx.
let sync_package = self.state.ecs_mut().next_sync_package();
self.state
    .notify_registered_clients(ServerMsg::EcsSync(sync_package));
```

So during state.tick() one of the systems, message, recieves messages from clients. If it gets a chat command, it pushes it onto the server event bus. So our /object chair is pushed onto this bus, but where does it get handled? In self.handle_events(), which occurs before state.tick(). This means we wait until the next tick to handle the chat command. This might introduce some latency but logically we are good so far. Now the next tick arrives and the chair is assembled and inserted into the world inside of self.handle_events().

Now we get to state.tick(). At this point, the chair is inserted into the RegionMap so we know what information the clients should recieve: position, orientation, and velocity. Then the systems are run including the entity_sync system which is responsible for sharing this information with the client. It happily does this, since the chair has no Last<Pos/Vel/Ori> components, and the client recieves this information.

```
ServerMsg::EntityPos { entity, pos } => {
    if let Some(entity) = self.state.ecs().entity_from_uid(entity) {
        self.state.write_component(entity, pos);
    }
}
ServerMsg::EntityVel { entity, vel } => {
    if let Some(entity) = self.state.ecs().entity_from_uid(entity) {
        self.state.write_component(entity, vel);
    }
}
ServerMsg::EntityOri { entity, ori } => {
    if let Some(entity) = self.state.ecs().entity_from_uid(entity) {
        self.state.write_component(entity, ori);
    }
}
```

The client then promptly converts the uid to its associated entity and uses that to insert the received value e.g. the position.... or does it ðŸ˜› We haven't reached the point where the client is told this entity exists and so the client just throws out this information. Meanwhile the server keeps going through the current tick, all the way to

`self.state.notify_registered_clients(ServerMsg::EcsSync(sync_package))`

Here, sphynx bundles up all the information it manages, like new entities! And that is sent to the clients. So the client recieves this and a positionless invisible chair is created on the client's side. And because that chair never moves we don't waste network bandwidth sending its position again.

# Player survey part 2

A few weeks ago, we had a survey that we send out about Veloren. We already went over some of the results [here](https://veloren.net/devblog-36/). We got lots of other information that we didn't cover there, so let's look at some more of it!

![](https://cdn.discordapp.com/attachments/541307708146581519/636383398406914058/unknown.png)
![](https://cdn.discordapp.com/attachments/541307708146581519/636384150999400459/unknown.png)
![](https://cdn.discordapp.com/attachments/541307708146581519/636384004567859220/unknown.png)

> What do you want Veloren developers to focus on? Blue is less interested, and increases to purple, which represents

This question gave a lot of data. There were th